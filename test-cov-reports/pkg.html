
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pansachin/employee-service/pkg/api/api.go (0.0%)</option>
				
				<option value="file1">github.com/pansachin/employee-service/pkg/api/context.go (0.0%)</option>
				
				<option value="file2">github.com/pansachin/employee-service/pkg/api/errorresponse.go (0.0%)</option>
				
				<option value="file3">github.com/pansachin/employee-service/pkg/api/middleware.go (0.0%)</option>
				
				<option value="file4">github.com/pansachin/employee-service/pkg/api/middleware/cors.go (0.0%)</option>
				
				<option value="file5">github.com/pansachin/employee-service/pkg/api/middleware/errors.go (0.0%)</option>
				
				<option value="file6">github.com/pansachin/employee-service/pkg/api/middleware/logger.go (0.0%)</option>
				
				<option value="file7">github.com/pansachin/employee-service/pkg/api/middleware/panics.go (0.0%)</option>
				
				<option value="file8">github.com/pansachin/employee-service/pkg/api/request.go (0.0%)</option>
				
				<option value="file9">github.com/pansachin/employee-service/pkg/api/respond.go (0.0%)</option>
				
				<option value="file10">github.com/pansachin/employee-service/pkg/api/shutdown.go (0.0%)</option>
				
				<option value="file11">github.com/pansachin/employee-service/pkg/database/db.go (0.0%)</option>
				
				<option value="file12">github.com/pansachin/employee-service/pkg/database/dbtest/dbtest.go (0.0%)</option>
				
				<option value="file13">github.com/pansachin/employee-service/pkg/database/errors.go (0.0%)</option>
				
				<option value="file14">github.com/pansachin/employee-service/pkg/database/pagination.go (0.0%)</option>
				
				<option value="file15">github.com/pansachin/employee-service/pkg/logger/logger.go (76.5%)</option>
				
				<option value="file16">github.com/pansachin/employee-service/pkg/validate/custom.go (41.0%)</option>
				
				<option value="file17">github.com/pansachin/employee-service/pkg/validate/errors.go (16.7%)</option>
				
				<option value="file18">github.com/pansachin/employee-service/pkg/validate/validate.go (90.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package api for handling API requests
package api

import (
        "context"
        "net/http"
        "os"
        "syscall"
        "time"

        "go.opentelemetry.io/otel/trace"
)

// A Handler is a type that handles a http request within the framework
type Handler func(ctx context.Context, w http.ResponseWriter, r *http.Request) error

// API is the entrypoint into our application and what configures our context
// object for each of our http handlers. Feel free to add any configuration
// data/logic on this Api struct
type API struct {
        mux      *http.ServeMux
        shutdown chan os.Signal
        mw       []Middleware
}

// NewAPI creates an Api value that handle a set of routes for the application
func NewAPI(shutdown chan os.Signal, mw ...Middleware) *API <span class="cov0" title="0">{

        mux := http.NewServeMux()

        return &amp;API{
                mux:      mux,
                shutdown: shutdown,
                mw:       mw,
        }
}</span>

// SignalShutdown is used to gracefully shut down the app when an integrity
// issue is identified
func (a *API) SignalShutdown() <span class="cov0" title="0">{
        a.shutdown &lt;- syscall.SIGTERM
}</span>

// Handle sets a handler function for a given HTTP method and path pair
// to the application server mux
func (a *API) Handle(method string, path string, handler Handler, mw ...Middleware) <span class="cov0" title="0">{

        // First wrap handler specific middleware around this handler
        handler = wrapMiddleware(mw, handler)

        // Add the api's general middleware to the handler chain.
        handler = wrapMiddleware(a.mw, handler)

        // Execute each specific request
        // The function to execute for each request.
        h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                // Pull the context from the request and
                // use it as a separate parameter.
                ctx := r.Context()

                // Capture the parent request span from the context.
                // Once we properly setup otel / tracing
                span := trace.SpanFromContext(ctx)

                // Set the context with the required values to
                // process the request.
                v := ContextValues{
                        TracerUID: span.SpanContext().TraceID().String(),
                        Now:       time.Now(),
                }
                ctx = context.WithValue(ctx, key, &amp;v)

                // Register this path and tracer uid for metrics later on
                _ = SetPath(ctx, path)

                // Call the wrapped handler functions.
                if err := handler(ctx, w, r); err != nil </span><span class="cov0" title="0">{
                        a.SignalShutdown()
                        return
                }</span>

        })

        <span class="cov0" title="0">a.mux.HandleFunc(method+" "+path, h)</span>
}

// ServeHTTP implements the http.Handler interface. It's the entry point for
// all http traffic.
func (a *API) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        a.mux.ServeHTTP(w, r)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "context"
        "errors"
        "time"
)

// ctxKey represents the type of value for the context key.
type ctxKey int

// key is how request values are stored/retrieved.
const key ctxKey = 1

// ContextValues represent state for each request.
type ContextValues struct {
        TracerUID  string
        Now        time.Time
        StatusCode int
        IsError    bool
        IsPanic    bool
        Path       string
}

// GetContextValues returns the values from the context.
func GetContextValues(ctx context.Context) (*ContextValues, error) <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*ContextValues)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("api value missing from context")
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// GetTracerUID returns the trace id from the context.
func GetTracerUID(ctx context.Context) string <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*ContextValues)
        if !ok </span><span class="cov0" title="0">{
                return "deadbeef-dead-beef-aaaa-000000000000"
        }</span>
        <span class="cov0" title="0">return v.TracerUID</span>
}

// SetTracerUID makes sure that the trace id is accessible via this context
func SetTracerUID(ctx context.Context, traceid string) error <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*ContextValues)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("api value missing from context")
        }</span>
        <span class="cov0" title="0">v.TracerUID = traceid
        return nil</span>
}

// SetStatusCode sets the status code back into the context.
func SetStatusCode(ctx context.Context, statusCode int) error <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*ContextValues)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("api value missing from context")
        }</span>
        <span class="cov0" title="0">v.StatusCode = statusCode
        return nil</span>
}

// SetIsError sets the error code back into the context.
func SetIsError(ctx context.Context) error <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*ContextValues)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("api value missing from context")
        }</span>
        <span class="cov0" title="0">v.IsError = true
        return nil</span>
}

// SetIsPanic sets a bool to see if this was a panic
func SetIsPanic(ctx context.Context) error <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*ContextValues)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("api value missing from context")
        }</span>
        <span class="cov0" title="0">v.IsPanic = true
        return nil</span>
}

// SetPath removes right slash and things like :id, :uid, :alias, etc
// This is used for metrics later without the DYNAMIC part
func SetPath(ctx context.Context, path string) error <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*ContextValues)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("api value missing from context")
        }</span>
        <span class="cov0" title="0">v.Path = path
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "errors"
)

// ErrorResponse is the form used for API responses from failures in the API.
// swagger:model ErrorResponse
type ErrorResponse struct {
        // in:body
        //
        //example: data is not in proper format
        Error string `json:"error"`
        // in:body
        //
        //example: {"field": "error message for this specific field"}
        Fields map[string]string `json:"fields,omitempty"`
}

// ErrorResponseID is the form used for API responses from failures in the API.
// swagger:model ErrorResponseID
type ErrorResponseID struct {
        // in:body
        //
        //example: ID is not in its proper form
        Error string `json:"error"`
        // in:body
        //
        //example: {"field": "error message for this specific field"}
        Fields map[string]string `json:"fields,omitempty"`
}

// ErrorResponseIDs is the form used for API responses from failures in the API.
// swagger:model ErrorResponseIDs
type ErrorResponseIDs struct {
        // in:body
        //
        //example: IDs are not in their proper form
        Error string `json:"error"`
        // in:body
        //
        //example: {"field": "error message for this specific field"}
        Fields map[string]string `json:"fields,omitempty"`
}

// ErrorResponseUUID is the form used for API responses from failures in the API.
// swagger:model ErrorResponseUUID
type ErrorResponseUUID struct {
        // in:body
        //
        //example: UUID is not in its proper form
        Error string `json:"error"`
        // in:body
        //
        //example: {"field": "error message for this specific field"}
        Fields map[string]string `json:"fields,omitempty"`
}

// RequestError is used to pass an error during the request through the
// application with web specific context.
type RequestError struct {
        Err    error
        Status int
}

// NewRequestError wraps a provided error with an HTTP status code. This
// function should be used when handlers encounter expected errors.
func NewRequestError(err error, status int) error <span class="cov0" title="0">{
        return &amp;RequestError{
                Err:    err,
                Status: status,
        }
}</span>

// Error implements the error interface. It uses the default message of the
// wrapped error. This is what will be shown in the services' logs.
func (re *RequestError) Error() string <span class="cov0" title="0">{
        return re.Err.Error()
}</span>

// IsRequestError checks if the error type RequestError Exists
func IsRequestError(err error) bool <span class="cov0" title="0">{
        var re *RequestError
        return errors.As(err, &amp;re)
}</span>

// GetRequestError returns a copy of the RequestError pointer.
func GetRequestError(err error) *RequestError <span class="cov0" title="0">{
        var re *RequestError
        if !errors.As(err, &amp;re) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return re</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

// Middleware is a function designed to run some code before and/or after
// another Handler. It is designed to remove boilerplate or other concerns not
// direct to any given Handler
type Middleware func(Handler) Handler

// wrapMiddleware creates a new handler by wrapping middleware around a final
// handler. The middlewares' Handlers will be executed by requests in the order
// they are provided
func wrapMiddleware(mw []Middleware, handler Handler) Handler <span class="cov0" title="0">{

        // Loop backwards through the middleware invoking each one. Replace the
        // handler with the new wrapped handler. Looping backwards ensures that the
        // first middleware of the slice is the first to be executed by requests.
        for i := len(mw) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                h := mw[i]
                if h != nil </span><span class="cov0" title="0">{
                        handler = h(handler)
                }</span>
        }

        <span class="cov0" title="0">return handler</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package middleware for middleware handlers
package middleware

import (
        "context"
        "net/http"

        "github.com/pansachin/employee-service/pkg/api"
)

// Cors sets the response headers needed for Cross-Origin Resource Sharing
func Cors(origin string) api.Middleware <span class="cov0" title="0">{

        // This is the actual middleware function to be executed
        m := func(handler api.Handler) api.Handler </span><span class="cov0" title="0">{

                // Create the handler that will be attached in the middleware chain.
                h := func(ctx context.Context, w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{

                        // Set the CORS headers to the response
                        w.Header().Set("Access-Control-Allow-Origin", origin)
                        w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
                        w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")

                        // Call the next handler.
                        return handler(ctx, w, r)
                }</span>

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/pansachin/employee-service/pkg/api"
        "github.com/pansachin/employee-service/pkg/database"
        "github.com/pansachin/employee-service/pkg/validate"
)

// Errors handles errors coming out of the call chain. It detects normal
// application errors which are used to respond to the client in a uniform way.
// Unexpected errors (status &gt;= 500) are logged.
func Errors(log *slog.Logger) api.Middleware <span class="cov0" title="0">{

        // This is the actual middleware function to be executed.
        m := func(handler api.Handler) api.Handler </span><span class="cov0" title="0">{

                // Create the handler that will be attached in the middleware chain.
                h := func(ctx context.Context, w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{

                        v, err := api.GetContextValues(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return api.NewShutdownError("api value missing from context")
                        }</span>

                        // Run the next handler and catch any propagated error.
                        <span class="cov0" title="0">err = handler(ctx, w, r)
                        if err != nil </span><span class="cov0" title="0">{

                                log.Error("CLIENT ERROR", "tracer_uid", v.TracerUID, slog.Any("ERROR", err))

                                // Build out the error response.
                                var er api.ErrorResponse
                                var status int

                                // Set the error count for the request middleware
                                _ = api.SetIsError(ctx)

                                switch </span>{
                                case database.IsError(err):<span class="cov0" title="0">
                                        reqErr := database.GetError(err)
                                        er = api.ErrorResponse{
                                                Error: reqErr.Error(),
                                        }
                                        status = reqErr.Status</span>

                                case validate.IsFieldErrors(err):<span class="cov0" title="0">
                                        fieldErrors := validate.GetFieldErrors(err)
                                        errMsg := validate.GetCustomError(err)
                                        if errMsg == "" </span><span class="cov0" title="0">{
                                                errMsg = "data validation error"
                                        }</span>
                                        <span class="cov0" title="0">er = api.ErrorResponse{
                                                Error:  errMsg,
                                                Fields: fieldErrors.Fields(),
                                        }
                                        status = http.StatusBadRequest</span>

                                case api.IsRequestError(err):<span class="cov0" title="0">
                                        reqErr := api.GetRequestError(err)
                                        er = api.ErrorResponse{
                                                Error: reqErr.Error(),
                                        }
                                        status = reqErr.Status</span>

                                default:<span class="cov0" title="0">
                                        status = http.StatusInternalServerError
                                        er = api.ErrorResponse{
                                                Error: err.Error(),
                                        }</span>
                                }

                                // Respond with the error back to the client
                                <span class="cov0" title="0">if err := api.Respond(ctx, w, er, status); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                // If we receive the shutdown err we need to return it
                                // back to the base handler to shut down the service
                                <span class="cov0" title="0">if ok := api.IsShutdown(err); ok </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return h</span>
        }
        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"
        "time"

        //"time"

        "github.com/pansachin/employee-service/pkg/api"
)

// Logger writes some information about the request to the logs in the
// format: TraceID : (200) GET /foo -&gt; IP ADDR (latency)
func Logger(log *slog.Logger) api.Middleware <span class="cov0" title="0">{
        // This is the actual middleware function to be executed.
        m := func(handler api.Handler) api.Handler </span><span class="cov0" title="0">{

                // Create the handler that will be attached in the middleware chain.
                h := func(ctx context.Context, w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{

                        v, err := api.GetContextValues(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return api.NewShutdownError("api value missing from context")
                        }</span>

                        <span class="cov0" title="0">start := time.Now()
                        ou := []string{""}
                        cn := ""
                        if r.TLS != nil &amp;&amp; len(r.TLS.VerifiedChains) &gt; 0 &amp;&amp; len(r.TLS.VerifiedChains[0]) &gt; 0 </span><span class="cov0" title="0">{
                                ou = r.TLS.VerifiedChains[0][0].Subject.OrganizationalUnit
                                cn = r.TLS.VerifiedChains[0][0].Subject.CommonName
                        }</span>

                        <span class="cov0" title="0">lw := log.With("component", "middleware:logger",
                                "tracer_uid", v.TracerUID,
                                "method", r.Method,
                                "uri", r.RequestURI,
                                "remote_addr", r.RemoteAddr,
                                "user_agent", r.UserAgent(),
                                "client_ou", ou,
                                "client_cn", cn,
                        )
                        lw.Info("request started")

                        // Call the next handler
                        err = handler(ctx, w, r)

                        latency := time.Since(start)
                        s := float64(latency.Microseconds()) / float64(1000000)
                        lw.Info("request completed",
                                "duration_s", s,
                                "response", v.StatusCode,
                        )

                        return err</span>
                }
                <span class="cov0" title="0">return h</span>
        }
        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "runtime/debug"

        "github.com/pansachin/employee-service/pkg/api"
)

// Panics recovers from panics and converts the panic to an error so it is
// reported in Metrics and handled in Errors.
func Panics() api.Middleware <span class="cov0" title="0">{

        // This is the actual middleware function to be executed.
        m := func(handler api.Handler) api.Handler </span><span class="cov0" title="0">{

                // Create the handler that will be attached in the middleware chain.
                h := func(ctx context.Context, w http.ResponseWriter, r *http.Request) (err error) </span><span class="cov0" title="0">{

                        defer func(ctx context.Context) </span><span class="cov0" title="0">{
                                if rec := recover(); rec != nil </span><span class="cov0" title="0">{

                                        trace := debug.Stack()
                                        err = fmt.Errorf("API PANIC [%v] TRACE:\n%s", rec, string(trace))

                                        _ = api.SetIsPanic(ctx)

                                }</span>
                        }(ctx)

                        // Call the next handler and set its return value in the err variable.
                        <span class="cov0" title="0">return handler(ctx, w, r)</span>
                }
                <span class="cov0" title="0">return h</span>
        }
        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "regexp"
        "strings"

        //nolint:all
        "io/ioutil"
)

// Param returns the web call parameters from the request
func Param(r *http.Request, key string) string <span class="cov0" title="0">{
        value := r.PathValue(key)
        return value
}</span>

// Decode reads the body of an HTTP request looking for a JSON document. The
// body is decoded into the provided value
// If the provided value is a struct then it is checked for validation tags
func Decode(r *http.Request, val interface{}) error <span class="cov0" title="0">{
        if err := checkPayload(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">decoder := json.NewDecoder(r.Body)
        decoder.DisallowUnknownFields()
        if err := decoder.Decode(val); err != nil </span><span class="cov0" title="0">{
                // Checks if this is a bad key, or wrong value
                var re = regexp.MustCompile(`(?m)field ([A-Za-z-_\.]+) (of type [A-Za-z]+)`)
                matches := re.FindStringSubmatch(err.Error())
                if len(matches) == 3 </span><span class="cov0" title="0">{
                        parts := strings.Split(matches[1], ".")
                        err = fmt.Errorf("invalid json: %s must be %s", parts[len(parts)-1], matches[2])
                        return NewRequestError(err, http.StatusBadRequest)
                }</span>

                // Unknown Fields
                <span class="cov0" title="0">if strings.Contains(err.Error(), "unknown field") </span><span class="cov0" title="0">{
                        str := strings.ReplaceAll(err.Error(), "\\", "")
                        str = strings.ReplaceAll(str, "\"", "")
                        str = strings.ReplaceAll(str, "unknown field", "unknown field:")
                        return NewRequestError(fmt.Errorf(str), http.StatusBadRequest)
                }</span>

                // Don't die on a decode failure
                <span class="cov0" title="0">return NewRequestError(err, http.StatusBadRequest)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func checkPayload(r *http.Request) error <span class="cov0" title="0">{

        // Need buffers to make sure we don't screw with the r.Body
        buf, _ := ioutil.ReadAll(r.Body)
        rdr1 := ioutil.NopCloser(bytes.NewBuffer(buf))
        rdr2 := ioutil.NopCloser(bytes.NewBuffer(buf))

        // Set the r.Body back to it's original state
        r.Body = rdr2

        // Check if empty for better error messages
        b, err := ioutil.ReadAll(rdr1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Empty Payload
        <span class="cov0" title="0">body := strings.TrimSpace(string(b))
        if body == "" </span><span class="cov0" title="0">{
                return NewRequestError(fmt.Errorf("json payload is empty"), http.StatusBadRequest)
        }</span>

        // Missing first or last { brackets }
        <span class="cov0" title="0">if body[:1] != "{" || body[len(body)-1:] != "}" </span><span class="cov0" title="0">{
                return NewRequestError(fmt.Errorf("json missing opening or closing brackets"), http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "reflect"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
)

// SuccessResponse is the form used for API responses for success in the API.
type SuccessResponse struct {
        // Success
        //
        Success bool `json:"success"`
        // Timestamp
        //
        // example: 1234567
        Timestamp int64 `json:"timestamp"`
        // Data
        // in: body
        Data interface{} `json:"data,omitempty"`
        // Errors
        // in: body
        Errors interface{} `json:"errors,omitempty"`
}

// Respond returns json to client
func Respond(ctx context.Context, w http.ResponseWriter, data interface{}, statusCode int) error <span class="cov0" title="0">{

        ctx, span := otel.GetTracerProvider().Tracer("").Start(ctx, "pkg.api.respond")
        span.SetAttributes(attribute.Int("statusCode", statusCode))

        // Set the status code for the request logger middleware
        err := SetStatusCode(ctx, statusCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If no data is provided, just return status code -- Always return something
        //if statusCode == http.StatusNoContent {
        //        w.WriteHeader(statusCode)
        //        return nil
        //}

        <span class="cov0" title="0">r := SuccessResponse{
                Success:   true,
                Timestamp: time.Now().UTC().Unix(),
                Data:      data,
        }
        // If it's an error, it does not need to re-marshal
        if reflect.TypeOf(data) == reflect.TypeOf(ErrorResponse{}) </span><span class="cov0" title="0">{
                r.Success = false
                r.Data = nil
                r.Errors = data
        }</span>

        // Convert the response to json
        <span class="cov0" title="0">jd, err := json.Marshal(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // set the content type now that we know there was no marshal error
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        // Send the result back to the client
        if _, err := w.Write(jd); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write fail: %+v", jd)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "errors"
)

// shutdownError is a type used to help with the graceful termination of the service.
type shutdownError struct {
        Message string
}

// NewShutdownError returns an error that causes the framework to signal
// a graceful shutdown.
func NewShutdownError(message string) error <span class="cov0" title="0">{
        return &amp;shutdownError{Message: message}
}</span>

// Error is the implementation of the error interface.
func (se *shutdownError) Error() string <span class="cov0" title="0">{
        return se.Message
}</span>

// IsShutdown checks to see if the shutdown error is contained
// in the specified error value.
func IsShutdown(err error) bool <span class="cov0" title="0">{
        var se *shutdownError
        return errors.As(err, &amp;se)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package database for database functions
package database

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/url"
        "reflect"
        "regexp"
        "strings"
        "time"

        // mysql driver import
        "cloud.google.com/go/compute/metadata"
        _ "github.com/go-sql-driver/mysql"
        "github.com/jmoiron/sqlx"

        "github.com/pansachin/employee-service/pkg/api"
)

// Set of error variables for CRUD operations.
var (
        ErrDBNotFound        = errors.New("data not found")
        ErrDBDuplicatedEntry = errors.New("duplicated entry")
)

// Config is the required properties for the db
type Config struct {
        Type         string
        User         string
        Password     string
        Host         string
        Port         int
        Name         string
        MaxIdleConns int
        MaxOpenConns int
        DisableTLS   bool
}

// DBResults to store database operation results
type DBResults struct {
        LastInsertID int64
        AffectedRows int64
}

// -----------------------------------------------------------------------
// Connection Information
// -----------------------------------------------------------------------

// Open a connection to a db
func Open(cfg Config) (*sqlx.DB, error) <span class="cov0" title="0">{
        fmt.Println("database")
        cs := connectionString(cfg)

        db, err := sqlx.Open(cfg.Type, cs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">db.SetMaxIdleConns(cfg.MaxIdleConns)
        db.SetMaxOpenConns(cfg.MaxOpenConns)

        return db, nil</span>
}

func connectionString(cfg Config) string <span class="cov0" title="0">{

        switch strings.ToLower(cfg.Type) </span>{
        case "pg", "psql", "pgsql", "postgres", "postgresql":<span class="cov0" title="0">
                return pgConnectionString(cfg)</span>

        case "mysql", "maria", "mariadb":<span class="cov0" title="0">
                return mysqlConnectionString(cfg)</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func mysqlConnectionString(cfg Config) string <span class="cov0" title="0">{
        // For Local
        if !metadata.OnGCE() </span><span class="cov0" title="0">{
                q := make(url.Values)
                q.Set("parseTime", "true")

                if cfg.Port &gt; 0 </span><span class="cov0" title="0">{
                        cfg.Host = fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)
                }</span>

                //Weird mysql issue, host:port has to have parenthesis around it
                <span class="cov0" title="0">cfg.Host = "(" + cfg.Host + ")"

                u := url.URL{
                        User:     url.UserPassword(cfg.User, cfg.Password),
                        Host:     cfg.Host,
                        Path:     cfg.Name,
                        RawQuery: q.Encode(),
                }
                return strings.Trim(u.String(), "/")</span>
        }
        // For CF in GCP
        <span class="cov0" title="0">u := fmt.Sprintf("%s:%s@unix(/%s)/%s?parseTime=true",
                cfg.User, cfg.Password, cfg.Host, cfg.Name)

        return strings.Trim(u, "/")</span>
}

func pgConnectionString(cfg Config) string <span class="cov0" title="0">{
        sslMode := "require"
        if cfg.DisableTLS </span><span class="cov0" title="0">{
                sslMode = "disable"
        }</span>

        <span class="cov0" title="0">q := make(url.Values)
        q.Set("sslmode", sslMode)
        q.Set("timezone", "utc")

        if cfg.Port &gt; 0 </span><span class="cov0" title="0">{
                cfg.Host = fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)
        }</span>

        <span class="cov0" title="0">u := url.URL{
                User:     url.UserPassword(cfg.User, cfg.Password),
                Host:     cfg.Host,
                Path:     cfg.Name,
                RawQuery: q.Encode(),
        }

        return u.String()</span>
}

// -----------------------------------------------------------------------
// Debugging
// -----------------------------------------------------------------------

// StatusCheck returns nil if it can successfully talk to the database. It
// returns a non-nil error otherwise.
func StatusCheck(ctx context.Context, db *sqlx.DB) error <span class="cov0" title="0">{

        // First check we can ping the database.
        var pingError error
        for attempts := 1; ; attempts++ </span><span class="cov0" title="0">{
                pingError = db.Ping()
                if pingError == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Duration(attempts) * 100 * time.Millisecond)
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>
        }

        // Make sure we didn't timeout or be cancelled.
        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>

        // Run a simple query to determine connectivity. Running this query forces a
        // round trip through the database.
        <span class="cov0" title="0">const q = `SELECT true`
        var tmp bool
        return db.QueryRowContext(ctx, q).Scan(&amp;tmp)</span>
}

// -----------------------------------------------------------------------
// Transactions
// -----------------------------------------------------------------------

// Transactor interface needed to begin transaction.
type Transactor interface {
        Beginx() (*sqlx.Tx, error)
}

// WithinTran runs passed function and does commit/rollback at the end.
func WithinTran(ctx context.Context, log *slog.Logger, db Transactor, fn func(sqlx.ExtContext) error) error <span class="cov0" title="0">{
        traceID := api.GetTracerUID(ctx)

        // Begin the transaction.
        log.Info("begin db transaction", "traceid", traceID)
        tx, err := db.Beginx()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin db transaction: %w", err)
        }</span>

        // Mark to the defer function a rollback is required.
        <span class="cov0" title="0">mustRollback := true

        // Set up a defer function for rolling back the transaction. If
        // mustRollback is true it means the call to fn failed, and we
        // need to roll back the transaction.
        defer func() </span><span class="cov0" title="0">{
                if mustRollback </span><span class="cov0" title="0">{
                        log.Info("rollback db transaction", "traceid", traceID)
                        if err := tx.Rollback(); err != nil </span><span class="cov0" title="0">{
                                log.Error("unable to rollback db transaction", "traceid", traceID, slog.Any("ERROR", err))
                        }</span>
                }
        }()

        // Execute the code inside the transaction. If the function
        // fails, return the error and the defer function will roll back.
        <span class="cov0" title="0">if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("exec db transaction: %w", err)
        }</span>

        // Disarm the deferred rollback.
        <span class="cov0" title="0">mustRollback = false

        // Commit the transaction.
        log.Info("commit db transaction", "traceid", traceID)
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit db transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// -----------------------------------------------------------------------
// Query Helpers
// -----------------------------------------------------------------------

// NamedExecContext is a helper function to execute a CUD operation with
// logging and tracing.
func NamedExecContext(ctx context.Context, log *slog.Logger, db sqlx.ExtContext, query string, data interface{}) (DBResults, error) <span class="cov0" title="0">{
        q := queryString(query, data)
        traceID := api.GetTracerUID(ctx)
        log.Debug("database.NamedExecContext", "traceid", traceID, "query", q)

        var dbres DBResults
        res, err := sqlx.NamedExecContext(ctx, db, query, data)
        if err != nil </span><span class="cov0" title="0">{
                return DBResults{}, err
        }</span>

        <span class="cov0" title="0">lid, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return DBResults{}, err
        }</span>
        <span class="cov0" title="0">dbres.LastInsertID = lid

        ra, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return DBResults{}, err
        }</span>
        <span class="cov0" title="0">dbres.AffectedRows = ra

        if val, err := res.RowsAffected(); err != nil </span><span class="cov0" title="0">{
                dbres.AffectedRows = val
        }</span>

        <span class="cov0" title="0">return dbres, err</span>
}

// NamedQuerySlice is a helper function for executing queries that return a
// collection of data to be unmarshalled into a slice.
func NamedQuerySlice(ctx context.Context, log *slog.Logger, db sqlx.ExtContext, query string, data interface{}, dest interface{}) error <span class="cov0" title="0">{
        q := queryString(query, data)
        traceID := api.GetTracerUID(ctx)
        log.Debug("database.NamedQuerySlice", "traceid", traceID, "query", q)
        val := reflect.ValueOf(dest)
        if val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return errors.New("must provide a pointer to a slice")
        }</span>

        <span class="cov0" title="0">rows, err := sqlx.NamedQueryContext(ctx, db, query, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:all

        slice := val.Elem()
        for rows.Next() </span><span class="cov0" title="0">{
                v := reflect.New(slice.Type().Elem())
                if err := rows.StructScan(v.Interface()); err != nil &amp;&amp; !strings.Contains(err.Error(), "unsupported Scan, storing driver.Value type &lt;nil&gt; into type *json.RawMessage") </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">slice.Set(reflect.Append(slice, v.Elem()))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// QueryxContextSlice is a helper function for executing queries that return a
// collection of data to be unmarshalled into a slice.
func QueryxContextSlice(ctx context.Context, log *slog.Logger, db sqlx.QueryerContext, query string, args []interface{}, dest interface{}) error <span class="cov0" title="0">{
        traceID := api.GetTracerUID(ctx)
        log.Debug("database.QueryxContextSlice", "traceid", traceID, "query", query, "args", args)
        val := reflect.ValueOf(dest)
        if val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return errors.New("must provide a pointer to a slice")
        }</span>

        <span class="cov0" title="0">rows, err := db.QueryxContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:all

        slice := val.Elem()
        for rows.Next() </span><span class="cov0" title="0">{
                v := reflect.New(slice.Type().Elem())
                if err := rows.StructScan(v.Interface()); err != nil &amp;&amp; !strings.Contains(err.Error(), "unsupported Scan, storing driver.Value type &lt;nil&gt; into type *json.RawMessage") </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">slice.Set(reflect.Append(slice, v.Elem()))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NamedQueryStruct is a helper function for executing queries that return a
// single value to be unmarshalled into a struct type.
func NamedQueryStruct(ctx context.Context, log *slog.Logger, db sqlx.ExtContext, query string, data interface{}, dest interface{}) error <span class="cov0" title="0">{
        traceID := api.GetTracerUID(ctx)
        log.Debug("database.NamedQuerySlice", "traceid", traceID, "query", query, "args", data)

        rows, err := sqlx.NamedQueryContext(ctx, db, query, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:all

        if !rows.Next() </span><span class="cov0" title="0">{
                return ErrDBNotFound
        }</span>

        <span class="cov0" title="0">if err := rows.StructScan(dest); err != nil &amp;&amp; !strings.Contains(err.Error(), "unsupported Scan, storing driver.Value type &lt;nil&gt; into type *json.RawMessage") </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// queryString provides a pretty print version of the query and parameters.
func queryString(query string, args ...interface{}) string <span class="cov0" title="0">{
        if args[0] == nil </span><span class="cov0" title="0">{
                return query
        }</span>

        <span class="cov0" title="0">argsValue := reflect.ValueOf(args)
        if argsValue.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">query, params, err := sqlx.Named(query, args)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>

        <span class="cov0" title="0">for _, param := range params </span><span class="cov0" title="0">{
                var value string
                switch v := param.(type) </span>{
                case *string:<span class="cov0" title="0">
                        value = fmt.Sprintf("%v", v)
                        if v != nil </span><span class="cov0" title="0">{
                                value = fmt.Sprintf(`'%s'`, *v)
                        }</span>
                case string, []byte:<span class="cov0" title="0">
                        value = fmt.Sprintf(`'%s'`, v)</span>
                case json.RawMessage:<span class="cov0" title="0">
                        value = fmt.Sprintf(`'%s'`, string(v))</span>
                default:<span class="cov0" title="0">
                        value = fmt.Sprintf("%v", v)</span>
                }
                <span class="cov0" title="0">query = strings.Replace(query, "?", value, 1)</span>
        }

        <span class="cov0" title="0">singleSpacePattern := regexp.MustCompile(`\s\s+`)
        query = singleSpacePattern.ReplaceAllString(query, " ")

        return strings.Trim(query, " ")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package dbtest for testing db
package dbtest

import (
        "bufio"
        "bytes"
        "context"
        "log/slog"
        "os"
        "testing"
        "time"

        "github.com/jmoiron/sqlx"

        "github.com/pansachin/employee-service/pkg/database"
)

// Success and failure markers.
const (
        Success = "\u2713"
        Failed  = "\u2717"
)

var (
        UnitDbConfig = database.Config{
                Type:       "mysql",
                User:       "root",
                Password:   "root",
                Host:       "localhost",
                Port:       7801,
                Name:       "employee",
                DisableTLS: true,
        }
)

// NewUnit for initializing unit tests
func NewUnit(t *testing.T) (*slog.Logger, *sqlx.DB, func()) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        db, err := database.Open(UnitDbConfig)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Opening database connection: %v", err)
        }</span>

        <span class="cov0" title="0">t.Log("Waiting for database to be ready ...")

        if err := database.StatusCheck(ctx, db); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("status check database: %v", err)
        }</span>

        <span class="cov0" title="0">t.Log("Creating test database ...")

        // Make sure we have sufficient permission for the db user
        if _, err := db.ExecContext(context.Background(), "CREATE DATABASE IF NOT EXISTS test_db"); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("dropping database test_db: %v", err)
        }</span>

        <span class="cov0" title="0">t.Log("Test database ready")

        _ = db.Close()

        testDbConfig := UnitDbConfig
        testDbConfig.Name = "test_db"
        db, err = database.Open(testDbConfig)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Opening database connection: %v", err)
        }</span>

        <span class="cov0" title="0">t.Log("Ready for testing ...")

        var buf bytes.Buffer
        writer := bufio.NewWriter(&amp;buf)
        log := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelDebug, AddSource: true}))

        // teardown is the function that should be invoked when the caller is done
        // with the database.
        teardown := func() </span><span class="cov0" title="0">{
                t.Helper()
                _ = db.Close()

                _ = writer.Flush()
                log.Info("******************** LOGS ********************")
                log.Info(buf.String())
                log.Info("******************** LOGS ********************")
        }</span>

        <span class="cov0" title="0">return log, db, teardown</span>
}

// StringPointer is a helper to get a *string from a string. It is in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func StringPointer(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

// IntPointer is a helper to get a *int from a int. It is in the tests package
// because we normally don't want to deal with pointers to basic types but it's
// useful in some tests.
func IntPointer(i int) *int <span class="cov0" title="0">{
        return &amp;i
}</span>

// BoolPointer is a helper to get a *bool from a bool.
// because we normally don't want to deal with pointers to basic types, but it's
// useful in some tests.
func BoolPointer(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import "errors"

// ErrorResponse is the form used for Database responses from failures in the DB
type ErrorResponse struct {
        Error  string            `json:"error"`
        Fields map[string]string `json:"fields,omitempty"`
}

// Error is used to pass an error during the request through the
// application with database specific context.
type Error struct {
        Err    error
        Status int
}

// NewError wraps a provided error with an HTTP status code. This
// function should be used when handlers encounter expected errors.
func NewError(err error, status int) error <span class="cov0" title="0">{
        return &amp;Error{
                Err:    err,
                Status: status,
        }
}</span>

// Error implements the error interface. It uses the default message of the
// wrapped error. This is what will be shown in the services' logs.
func (re *Error) Error() string <span class="cov0" title="0">{
        return re.Err.Error()
}</span>

// IsError checks if the error type Error Exists
func IsError(err error) bool <span class="cov0" title="0">{
        var re *Error
        return errors.As(err, &amp;re)
}</span>

// GetError returns a copy of the Error pointer.
func GetError(err error) *Error <span class="cov0" title="0">{
        var re *Error
        if !errors.As(err, &amp;re) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return re</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "fmt"
        "net/http"
        "regexp"
        "strconv"
        "strings"

        "github.com/pansachin/employee-service/pkg/api"
)

// Pagination details
// swagger:parameters EmployeeQuery
type Pagination struct {
        // The current page
        //
        // in: query
        // type: integer
        // enum: 1
        // minimum: 1
        // required: false
        Page int `db:"page" json:"page"`
        // The per page limit
        //
        // in: query
        // type: integer
        // enum: 20
        // minimum: 1
        // maximum: 100
        // required: false
        PerPage int `db:"per_page" json:"per_page"`
        // The column to sort on
        //
        // in: query
        // required: false
        // type: string
        // enum: created,updated
        // description:
        //   Sort order:
        //   - `created` - When the record was created in the database
        //   - `updated` - When the record was last touched in the database
        Sort string `db:"sort" json:"sort"`
        // The direction of the sort
        //
        // in: query
        // required: false
        // type: string
        // enum: asc,desc
        // description:
        //   Sort order:
        //   - `asc` - Ascending, from A to Z
        //   - `desc` - Descending, from Z to A
        Direction string `db:"direction" json:"direction"`
}

// PaginationResults Pagination details
// swagger:parameters sampleResultsQuery
type PaginationResults struct {
        // The current page
        //
        // in: query
        // type: integer
        // enum: 1
        // minimum: 1
        // required: false
        Page int `db:"page" json:"page"`
        // The per page limit
        //
        // in: query
        // type: integer
        // enum: 20
        // minimum: 1
        // maximum: 100
        // required: false
        PerPage int `db:"per_page" json:"per_page"`
        // The column to sort on
        //
        // in: query
        // required: false
        // type: string
        // enum: created
        // description:
        //   Sort order:
        //   - `created` - When the record was created in the database
        Sort string `db:"sort" json:"sort"`
        // The direction of the sort
        //
        // in: query
        // required: false
        // type: string
        // enum: asc,desc
        // description:
        //   Sort order:
        //   - `asc` - Ascending, from A to Z
        //   - `desc` - Descending, from Z to A
        Direction string `db:"direction" json:"direction"`
}

// NewPagination to initialize the pagination
func NewPagination() Pagination <span class="cov0" title="0">{
        return Pagination{
                Page:      0,
                PerPage:   20,
                Sort:      "created_on",
                Direction: "desc",
        }
}</span>

// PaginationParams simple function to get, validate, and compute
// pagination values
func PaginationParams(r *http.Request) (Pagination, error) <span class="cov0" title="0">{
        qparams := r.URL.Query()
        singleSpacePattern := regexp.MustCompile(`\s+`)

        pagi := NewPagination()

        if val, ok := qparams["per_page"]; ok </span><span class="cov0" title="0">{
                perPage, err := strconv.Atoi(val[0])
                if err != nil </span><span class="cov0" title="0">{
                        return Pagination{}, api.NewRequestError(fmt.Errorf("invalid perPage format: %s", val[0]), http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">if perPage &lt; 0 </span><span class="cov0" title="0">{
                        perPage = 20
                }</span>
                <span class="cov0" title="0">if perPage &gt; 100 </span><span class="cov0" title="0">{
                        perPage = 100
                }</span>
                <span class="cov0" title="0">pagi.PerPage = perPage</span>
        }

        <span class="cov0" title="0">if val, ok := qparams["page"]; ok </span><span class="cov0" title="0">{
                page, err := strconv.Atoi(val[0])
                if err != nil </span><span class="cov0" title="0">{
                        return Pagination{}, api.NewRequestError(fmt.Errorf("invalid page format: %s", val[0]), http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">page = page - 1
                if page &lt; 0 </span><span class="cov0" title="0">{
                        page = 0
                }</span>
                <span class="cov0" title="0">pagi.Page = page * pagi.PerPage</span>
        }

        <span class="cov0" title="0">if val, ok := qparams["sort"]; ok </span><span class="cov0" title="0">{
                val[0] = singleSpacePattern.ReplaceAllString(val[0], "")
                sort := strings.ToLower(val[0])
                // "created" set by default
                if sort == "updated" </span><span class="cov0" title="0">{
                        pagi.Sort = "updated_on"
                }</span>
                <span class="cov0" title="0">if sort == "id" </span><span class="cov0" title="0">{
                        pagi.Sort = "id"
                }</span>
        }

        <span class="cov0" title="0">if val, ok := qparams["direction"]; ok </span><span class="cov0" title="0">{
                val[0] = singleSpacePattern.ReplaceAllString(val[0], "")
                sort := strings.ToLower(val[0])
                // "created" set by default
                if sort == "asc" </span><span class="cov0" title="0">{
                        pagi.Direction = "asc"
                }</span>
        }

        <span class="cov0" title="0">return pagi, nil</span>
}

// PaginationQuery Placeholders ('?') can only be used to insert dynamic,
//
//        escaped values for filter parameters (e.g. in the WHERE part), where
//
// data values should appear, not for SQL keywords, identifiers etc. You
// cannot use it to dynamically specify the ORDER BY OR GROUP BY values.
// https://stackoverflow.com/questions/30867337/golang-order-by-issue-with-mysql
func PaginationQuery(pagi Pagination, q string) string <span class="cov0" title="0">{
        q = strings.ReplaceAll(q, ":sort", pagi.Sort)
        q = strings.ReplaceAll(q, ":direction", pagi.Direction)
        return q
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package logger for logger functions
package logger

import (
        "io"
        "log/slog"
        "os"
        "strings"
)

// Config holds the is the logger instance configuratoin.
type Config struct {
        // Writer is the writer to write the logs to.
        // It will set the writer to the provided value.
        //
        // If not provided, it will default to os.Stdout.
        Writer io.Writer

        // Source is the source information flag.
        // It will set AddSource to true.
        //
        // If not provided, it will default to true.
        Source bool

        // Debug sets the level of logging
        //
        // By default it's false
        Debug bool

        // json decideds on in which format log will be printed
        //
        // Default it's sets to false and print's logs in text format.
        Json bool
}

// NewLogger return a new instance of logger initalized based on passed config.
func NewLogger(config *Config, appname string, appversion string) (*slog.Logger, error) <span class="cov8" title="1">{
        // Fetch app version if not found
        // When running locally, the VERSION file is in the root of the project
        if appversion == "" </span><span class="cov0" title="0">{
                // Ignore errors, this is optional
                version, _ := os.ReadFile("../../VERSION")
                if version != nil </span><span class="cov0" title="0">{
                        appversion = strings.TrimSpace(string(version))
                }</span>
        }

        <span class="cov8" title="1">if config.Json </span><span class="cov8" title="1">{
                return NewJSONLogger(config, appname, appversion)
        }</span>
        <span class="cov0" title="0">return NewTextLogger(config, appname, appversion)</span>
}

// NewTextLogger returns a text logger
// For local use
func NewTextLogger(config *Config, appname string, appversion string) (*slog.Logger, error) <span class="cov8" title="1">{
        // Default is INFO
        var loglevel slog.Level
        if config.Debug </span><span class="cov8" title="1">{
                loglevel = slog.LevelDebug
        }</span>

        <span class="cov8" title="1">handler := slog.NewTextHandler(
                config.Writer,
                &amp;slog.HandlerOptions{
                        Level:     loglevel,
                        AddSource: config.Source,
                }).WithAttrs([]slog.Attr{
                slog.String("service", appname),
                slog.String("version", appversion),
        })

        return slog.New(handler), nil</span>
}

// NewJSONLogger retrns a JSON logger
// Use in development and production environments - GCP environment
func NewJSONLogger(config *Config, appname string, appversion string) (*slog.Logger, error) <span class="cov8" title="1">{
        // Default is INFO
        var loglevel slog.Level
        if config.Debug </span><span class="cov8" title="1">{
                loglevel = slog.LevelDebug
        }</span>

        <span class="cov8" title="1">handler := slog.NewJSONHandler(
                config.Writer,
                &amp;slog.HandlerOptions{
                        Level:     loglevel,
                        AddSource: config.Source,
                }).WithAttrs([]slog.Attr{
                slog.String("service", appname),
                slog.String("version", appversion),
        })

        return slog.New(handler), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package validate

import (
        "fmt"
        "reflect"
        "strings"

        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
)

// RegisterCustomValidators Custom Validations and error messages
func RegisterCustomValidators(validate *validator.Validate, translator ut.Translator) error <span class="cov8" title="1">{
        // Slugs
        if err := validate.RegisterValidation("slug", IsSlug); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterValidation: %w", err)
        }</span>
        <span class="cov8" title="1">if err := isSlugCustomError(translator); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("isSlugCustomError: %w", err)
        }</span>

        // Not blank
        <span class="cov8" title="1">if err := validate.RegisterValidation("notblank", NotBlank); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterValidation: %w", err)
        }</span>
        <span class="cov8" title="1">if err := notBlankCustomError(translator); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("notBlank: %w", err)
        }</span>

        // Headers required
        <span class="cov8" title="1">if err := validate.RegisterValidation("header", headersRequired); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterValidation: %w", err)
        }</span>
        <span class="cov8" title="1">if err := headersRequiredCustomError(translator); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("header: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// -----------------------------------------------------------------------
// Custom Validations
// -----------------------------------------------------------------------

// IsSlug checks if things are properly formed slugs
// Example: https://you.tools/slugify/
func IsSlug(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        field := fl.Field()

        if err := CheckSlug(field.String()); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
func isSlugCustomError(trans ut.Translator) error <span class="cov8" title="1">{
        return validate.RegisterTranslation("slug", trans, func(ut ut.Translator) error </span><span class="cov8" title="1">{
                return ut.Add("slug", "{0} is not in its proper form", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("slug", fe.Field())
                return t
        }</span>)
}

// NotBlank is the validation function for validating if the current field
// has a value or length greater than zero, or is not a space only string.
func NotBlank(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        field := fl.Field()

        switch field.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return len(strings.TrimSpace(field.String())) &gt; 0</span>
        case reflect.Chan, reflect.Map, reflect.Slice, reflect.Array:<span class="cov0" title="0">
                return field.Len() &gt; 0</span>
        case reflect.Ptr, reflect.Interface, reflect.Func:<span class="cov0" title="0">
                return !field.IsNil()</span>
        case reflect.Bool:<span class="cov0" title="0">
                return field.IsValid()</span>
        default:<span class="cov0" title="0">
                return field.IsValid() &amp;&amp; field.Interface() != reflect.Zero(field.Type()).Interface()</span>
        }
}

func notBlankCustomError(trans ut.Translator) error <span class="cov8" title="1">{
        return validate.RegisterTranslation("notblank", trans, func(ut ut.Translator) error </span><span class="cov8" title="1">{
                return ut.Add("notblank", "{0} cannot be blank", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("notblank", fe.Field())
                return t
        }</span>)
}

// headersRequired checks if things are properly uuid headers
func headersRequired(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        field := fl.Field()
        _ = field.String()

        return NotBlank(fl)
}</span>
func headersRequiredCustomError(trans ut.Translator) error <span class="cov8" title="1">{
        return validate.RegisterTranslation("header", trans, func(ut ut.Translator) error </span><span class="cov8" title="1">{
                return ut.Add("header", "{0} is a required header", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("header", fe.Field())
                return t
        }</span>)
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package validate

import (
        "encoding/json"
        "errors"
)

// FieldError is used to indicate an error with a specific request field.
type FieldError struct {
        Field string `json:"field"`
        Error string `json:"error"`
}

// FieldErrors represents a collection of field errors.
type FieldErrors struct {
        FieldError  []FieldError
        CustomError string `json:"omitempty"`
}

// Error implements the error interface.
func (fe FieldErrors) Error() string <span class="cov8" title="1">{
        d, err := json.Marshal(fe)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov8" title="1">return string(d)</span>
}

// Fields returns the fields that failed validation
func (fe FieldErrors) Fields() map[string]string <span class="cov0" title="0">{
        m := make(map[string]string)
        for _, fld := range fe.FieldError </span><span class="cov0" title="0">{
                m[fld.Field] = fld.Error
        }</span>
        <span class="cov0" title="0">return m</span>
}

// IsFieldErrors checks if an error of type FieldErrors exists.
func IsFieldErrors(err error) bool <span class="cov0" title="0">{
        var fe FieldErrors
        return errors.As(err, &amp;fe)
}</span>

// GetFieldErrors returns a copy of the FieldErrors pointer.
func GetFieldErrors(err error) FieldErrors <span class="cov0" title="0">{
        var fe FieldErrors
        if !errors.As(err, &amp;fe) </span><span class="cov0" title="0">{
                return FieldErrors{}
        }</span>
        <span class="cov0" title="0">return fe</span>
}

// GetCustomError returns a custom error message if it exists
func GetCustomError(err error) string <span class="cov0" title="0">{
        var fe FieldErrors
        if !errors.As(err, &amp;fe) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return fe.CustomError</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package validate for validate functions
package validate

import (
        "errors"
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"

        "github.com/go-playground/locales/en"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        en_translations "github.com/go-playground/validator/v10/translations/en"
        "github.com/google/uuid"
)

// validate holds the settings and caches for validating request struct values.
var validate *validator.Validate

// translator is a cache of locale and translation information.
var translator ut.Translator

func init() <span class="cov8" title="1">{
        // Instantiate a validator.
        validate = validator.New()

        // Create a translator for english so the error messages are
        // more human-readable than technical.
        translator, _ = ut.New(en.New(), en.New()).GetTranslator("en")

        // Register the english error messages for use.
        if err := en_translations.RegisterDefaultTranslations(validate, translator); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use JSON tag names for errors instead of Go struct names.
        <span class="cov8" title="1">validate.RegisterTagNameFunc(func(fld reflect.StructField) string </span><span class="cov8" title="1">{
                name := strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
                if name == "-" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov8" title="1">return name</span>
        })

        // -------------------------------------------------------------------
        // Custom Validations and error messages
        // -------------------------------------------------------------------
        <span class="cov8" title="1">_ = RegisterCustomValidators(validate, translator)</span>
}

// Check validates the provided model against it's declared tags.
func Check(val interface{}) error <span class="cov8" title="1">{

        if err := validate.Struct(val); err != nil </span><span class="cov8" title="1">{
                // Use a type assertion to get the real error value.
                verrors, ok := err.(validator.ValidationErrors)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("validator errors: %s", err)
                }</span>

                <span class="cov8" title="1">var fields FieldErrors
                for _, verror := range verrors </span><span class="cov8" title="1">{
                        field := FieldError{
                                Field: verror.Field(),
                                Error: verror.Translate(translator),
                        }
                        fields.FieldError = append(fields.FieldError, field)
                }</span>

                <span class="cov8" title="1">return fields</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CheckUUID validates that the format of an id is valid.
func CheckUUID(uid string) error <span class="cov8" title="1">{
        if _, err := uuid.Parse(uid); err != nil </span><span class="cov8" title="1">{
                return errors.New("UUID is not in its proper form")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CheckID validates that the format of an id is valid.
func CheckID(id string) error <span class="cov8" title="1">{
        return PositiveInt(id)
}</span>

// CheckSlug validates that format meets strong alias formatting
func CheckSlug(str string) error <span class="cov8" title="1">{
        if err := CheckString(str); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var re = regexp.MustCompile(`^[a-z0-9]+(?:[_-][a-z0-9]+)*$`)
        if len(re.FindStringIndex(str)) == 0 </span><span class="cov8" title="1">{
                return errors.New("invalid slug")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CheckString validates that the format of an id is valid.
func CheckString(str string) error <span class="cov8" title="1">{
        if str := strings.TrimSpace(str); str == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("string can not be blank")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PositiveInt validates that the format of an id is valid.
func PositiveInt(num string) error <span class="cov8" title="1">{
        i, err := strconv.Atoi(num)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s is not a valid number", num)
        }</span>
        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("value cannot be zero")
        }</span>
        <span class="cov8" title="1">if i &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("value cannot be negative")
        }</span>
        <span class="cov8" title="1">maxInt := 1&lt;&lt;32 - 1
        if i &gt; maxInt </span><span class="cov8" title="1">{
                return fmt.Errorf("value cannot be greater than %d", maxInt)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
